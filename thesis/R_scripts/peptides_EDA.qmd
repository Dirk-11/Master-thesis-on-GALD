---
title: "peptides_EDA"
format: html
editor: visual
---

#### Peptide analysis

```{r}
suppressPackageStartupMessages({
  library(tidyverse); library(readr); library(tidyr); library(matrixStats)
  library(pheatmap); library(RColorBrewer); library(UpSetR)
})

# ---- Files (edit paths if needed) ----
evidence_file   <- "evidence.txt"
peptides_file   <- "peptides.txt"      # optional enrich
allpeptides_file<- "allPeptides.txt"   # optional enrich
sample_map_file <- "sample_map.tsv"    # must exist: raw_file, sample, group

# ---- Load sample map ----
smap <- read_tsv(sample_map_file, show_col_types = FALSE)
stopifnot(all(c("Raw file","sample","group") %in% names(smap)))

# ---- Read MaxQuant evidence (primary source of peptide intensities) ----
# We only rely on columns that are standard in evidence.txt:
#   Sequence, Raw file, Intensity, Leading razor protein (optional but usual)
ev_cols <- c("Sequence","Raw file","Intensity","Leading razor protein")
ev <- read_tsv(evidence_file, show_col_types = FALSE)

stopifnot(all(c("Sequence","Raw file","Intensity") %in% names(ev)))

# Normalise column names we need
names(ev) <- names(ev) %>% str_replace_all(" ", "_")

# Safe presence of leading protein
has_lead <- "Leading_razor_protein" %in% names(ev)

# Keep only needed columns
ev <- ev %>%
  transmute(
    Sequence = Sequence,
    Raw_file = `Raw_file`,
    Intensity = suppressWarnings(as.numeric(Intensity)),
    Leading_razor_protein = if (has_lead) Leading_razor_protein else NA_character_
  )

# Map raw_file -> sample, group
df_pep <- ev %>%
  inner_join(smap %>% rename(Raw_file = 'Raw file'), by = "Raw_file") %>%
  # Aggregate to one Intensity per (peptide, sample). Sum is a common choice.
  group_by(Sequence, sample, group) %>%
  summarise(Intensity = sum(Intensity, na.rm = TRUE),
            Leading_razor_protein = first(Leading_razor_protein),
            .groups = "drop")

# Guard against all-zero rows becoming 0 but not detected; convert 0 to NA for 'absent'
df_pep <- df_pep %>% mutate(Intensity = ifelse(is.finite(Intensity) & Intensity > 0, Intensity, NA_real_))

# Optional: add info from peptides.txt / allPeptides.txt if present (non-essential)
add_peptides <- function(d, path) {
  if (file.exists(path)) {
    p <- read_tsv(path, guess_max = 2e6, show_col_types = FALSE)
    nm <- names(p) %>% str_replace_all(" ", "_")
    names(p) <- nm
    # Only keep safe columns if they exist
    keep <- intersect(c("Sequence","Proteins","Leading_razor_protein"), names(p))
    if (length(keep)) {
      p <- p %>% select(all_of(keep)) %>% distinct()
      d <- d %>% left_join(p, by = "Sequence", suffix = c("", ".pep"))
    }
  }
  d
}
df_pep <- add_peptides(df_pep, peptides_file)
df_pep <- add_peptides(df_pep, allpeptides_file)

# Define an "id_col" analogous to proteins EDA (now it's the peptide sequence)
id_col <- "Sequence"

# Optional antibody flag from leading protein (works only if we have it)
df_pep <- df_pep %>%
  mutate(
    base_lead = toupper(coalesce(Leading_razor_protein, "")),
    is_antibody = str_detect(base_lead, "^(IGH|IGK|IGL|IGJ)") | base_lead %in% c("JCHAIN")
  )


```

```{r}
df_pep <- ev %>%
  inner_join(smap %>% rename(Raw_file = `Raw file`), by = "Raw_file") %>%
  group_by(Sequence, sample, group) %>%
  summarise(
    Intensity = sum(Intensity, na.rm = TRUE),
    Leading_razor_protein = first(Leading_razor_protein),
    .groups = "drop"
  ) %>%
  mutate(Intensity = ifelse(is.finite(Intensity) & Intensity > 0, Intensity, NA_real_))

id_col <- "Sequence"


```

```{r}
# total peptides
total_peptides <- df_pep %>% distinct(!!sym(id_col)) %>% nrow()

# antibody-mapped peptides (optional, depends on Leading razor protein)
total_antibody_peptides <- df_pep %>%
  filter(str_detect(Leading_razor_protein, "^(IGH|IGK|IGL|IGJ)")) %>%
  distinct(!!sym(id_col)) %>% nrow()

# missingness and central tendency
frac_missing <- mean(is.na(df_pep$Intensity))
median_intensity <- median(df_pep$Intensity, na.rm = TRUE)

# sample/group counts
n_samples <- n_distinct(df_pep$sample)
n_groups  <- n_distinct(df_pep$group)

summary_tbl <- tibble(
  Metric = c("Total unique peptides",
             "Total antibody-mapped peptides",
             "Fraction missing values",
             "Median intensity (raw scale)",
             "Number of samples",
             "Number of groups"),
  Value = c(total_peptides,
            total_antibody_peptides,
            round(frac_missing, 3),
            round(median_intensity, 2),
            n_samples,
            n_groups)
)
summary_tbl

```

```{r}
pep_counts <- df_pep %>%
  group_by(sample, group) %>%
  summarise(n_peptides = sum(!is.na(Intensity)), .groups = "drop")

ggplot(pep_counts, aes(x = group, y = n_peptides, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  theme_minimal() +
  labs(title = "Peptides detected per sample",
       y = "Number of peptides", x = "Group") +
  theme(axis.text.x = element_text(angle = 90))

```

```{r}
ggplot(df_pep, aes(x = log2(Intensity), color = group, fill = group)) +
  geom_density(alpha = 0.2) +
  theme_minimal() +
  labs(title = "Distribution of peptide intensities per group",
       x = "Intensity (raw)", y = "Density")

ggplot(df_pep, aes(x = group, y = log2(Intensity), fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  coord_flip() +
  theme_minimal() +
  labs(title = "Peptide intensity distributions per group",
       y = "Intensity (raw)", x = "Group")

```

```{r}
library(UpSetR)

present <- df_pep %>%
  group_by(group, !!sym(id_col)) %>%
  summarise(present = any(!is.na(Intensity)), .groups = "drop")

mat <- present %>%
  mutate(val = as.integer(present)) %>%
  select(group, !!sym(id_col), val) %>%
  distinct() %>%
  pivot_wider(names_from = group, values_from = val, values_fill = 0) %>%
  arrange(!!sym(id_col)) %>%
  distinct(!!sym(id_col), .keep_all = TRUE) %>%
  column_to_rownames(id_col)

upset(as.data.frame(mat),
      nsets = min(8, ncol(mat)),
      nintersects = 20,
      order.by = "freq",
      mainbar.y.label = "Intersection size",
      sets.x.label = "Peptides per group")

# unique counts
colSums(mat == 1 & rowSums(mat) == 1)

```

d

```{r}
suppressPackageStartupMessages({ library(tidyverse) })

# Load evidence.txt (assuming already cleaned as ev)
# If not, replace with: ev <- read_tsv("evidence.txt", show_col_types = FALSE)

# Normalize column names
names(ev) <- names(ev) %>% str_replace_all(" ", "_")

# Sanity check: must have these
stopifnot(all(c("Sequence","Proteins","Leading_razor_protein") %in% names(ev)))

# Peptides with no identifier: both fields NA or empty
no_id_peptides <- ev %>%
  filter((is.na(Proteins) | Proteins == "") &
         (is.na(Leading_razor_protein) | Leading_razor_protein == "")) %>%
  distinct(Sequence)

n_no_id_peptides <- nrow(no_id_peptides)

message("Total number of peptides without any identifier: ", n_no_id_peptides)

# Save list if needed
readr::write_csv(no_id_peptides, "all_peptides_no_identifier.csv")

n_no_id_peptides

```

```{r}
gald_group <- "Fetal_liver_lysate_bait"   # adjust if name differs

present_pep <- df_pep %>%
  group_by(!!sym(id_col), group) %>%
  summarise(present = any(!is.na(Intensity)), .groups = "drop")

present_summary <- present_pep %>%
  group_by(!!sym(id_col)) %>%
  summarise(
    in_gald   = any(group == gald_group & present),
    in_others = any(group != gald_group & present),
    .groups = "drop"
  )

gald_unique_peptides <- present_summary %>%
  filter(in_gald, !in_others) %>%
  pull(!!sym(id_col))

gald_unique_peptides

```

d

```{r}
gald_group <- "Fetal_liver_lysate_bait"   # adjust if name differs
id_col <- "Sequence"                      # or whatever column stores peptide IDs

# Presence and counts per group
present_pep <- df_pep %>%
  group_by(!!sym(id_col), group) %>%
  summarise(
    present = any(!is.na(Intensity)),
    count   = sum(!is.na(Intensity)),   # how many times peptide detected
    .groups = "drop"
  )

# Summarize across groups
present_summary <- present_pep %>%
  group_by(!!sym(id_col)) %>%
  summarise(
    in_gald       = any(group == gald_group & present),
    in_others     = any(group != gald_group & present),
    count_in_gald = sum(count[group == gald_group]),
    count_in_others = sum(count[group != gald_group]),
    total_count   = sum(count),
    .groups = "drop"
  )

# Extract GALD-unique peptides (with counts)
gald_unique_peptides <- present_summary %>%
  filter(in_gald, !in_others)

gald_unique_peptides

```

```{r}
# --- Table of GALD-unique peptides with Leading razor protein ---

# helper to pick the most frequent non-NA string (mode)
pick_mode <- function(x) {
  x <- x[!is.na(x) & nzchar(x)]
  if (!length(x)) NA_character_ else names(sort(table(x), decreasing = TRUE))[1]
}

# Map each peptide sequence to its (modal) Leading razor protein from evidence
lrp_map <- ev %>%
  group_by(Sequence) %>%
  summarise(Leading_razor_protein = pick_mode(Leading_razor_protein), .groups = "drop")

# Build the output table
gald_unique_tbl <- gald_unique_peptides %>%
  transmute(Sequence = as.character(Sequence)) %>%       # flatten to plain character
  left_join(lrp_map %>% mutate(Sequence = as.character(Sequence)),
            by = "Sequence") %>%
  arrange(Leading_razor_protein, Sequence)


# Save and show
readr::write_csv(gald_unique_tbl, "gald_unique_peptides_with_leading_protein.csv")
gald_unique_tbl

```

```{r}
suppressPackageStartupMessages({ library(tidyverse) })

# --- helpers ---
pick_mode <- function(x) { x <- x[!is.na(x) & nzchar(x)];
  if (!length(x)) NA_character_ else names(sort(table(x), decreasing=TRUE))[1] }

norm_key <- function(x) {
  # Uppercase; take first entry if ';' separated; drop isoform suffix like '-1'
  x <- toupper(coalesce(as.character(x), ""))
  x <- sub(";.*$", "", x)
  x <- sub("-\\d+$", "", x)
  trimws(x)
}

# ===================== 1) Build peptide -> protein map from evidence =====================
# (use the most frequent Leading razor protein per peptide; also keep Protein IDs if available)
has_pids <- "Protein_IDs" %in% names(ev)  # in evidence.txt it's "Protein IDs" -> "Protein_IDs" after name normalization
pep_map <- ev %>%
  group_by(Sequence) %>%
  summarise(
    Leading_razor_protein = pick_mode(Leading_razor_protein),
    Protein_IDs = if (has_pids) pick_mode(Protein_IDs) else NA_character_,
    .groups = "drop"
  )

# Start from your GALD-unique list
gald_unique_tbl <- tibble(Sequence = gald_unique_peptides) %>%
  left_join(pep_map, by = "Sequence")

# ===================== 2) Build protein lookup from original.tsv =====================
prot <- readr::read_tsv("original.tsv", show_col_types = FALSE)
# normalize original.tsv column names once
names(prot) <- names(prot) %>% str_replace_all(" ", "_")

# Must-have columns in original.tsv for this step (from your schema)
stopifnot(all(c("identifier","leading_razor_protein","gene_name") %in% names(prot)))

prot_map_lr <- prot %>%
  distinct(identifier, leading_razor_protein, gene_name) %>%
  mutate(lead_key = norm_key(leading_razor_protein)) %>%
  select(lead_key,
         Identifier = identifier,
         Gene = gene_name)

# Fallback mapping via identifier itself (useful when we only have Protein IDs)
prot_map_id <- prot %>%
  distinct(identifier, gene_name) %>%
  mutate(id_key = norm_key(identifier)) %>%
  select(id_key,
         Identifier = identifier,
         Gene = gene_name)

# ===================== 3) Join by Leading razor protein first =====================
res1 <- gald_unique_tbl %>%
  mutate(lead_key = norm_key(Leading_razor_protein)) %>%
  left_join(prot_map_lr, by = "lead_key")

# ===================== 4) Fallback join by Protein IDs (if present) =====================
if (has_pids) {
  # Expand Protein_IDs and try to match to original identifiers
  pid_long <- res1 %>%
    select(Sequence, Protein_IDs) %>%
    filter(!is.na(Protein_IDs) & nzchar(Protein_IDs)) %>%
    separate_rows(Protein_IDs, sep = ";") %>%
    mutate(id_key = norm_key(Protein_IDs)) %>%
    left_join(prot_map_id, by = "id_key") %>%
    group_by(Sequence) %>%                 # if multiple IDs map, keep the first (or choose a rule you prefer)
    summarise(Identifier_pid = first(Identifier),
              Gene_pid       = first(Gene), .groups = "drop")

  # Fill in any missing Identifier/Gene from the PID route
  res_final <- res1 %>%
    left_join(pid_long, by = "Sequence") %>%
    mutate(
      Identifier = coalesce(Identifier, Identifier_pid),
      Gene       = coalesce(Gene,       Gene_pid)
    ) %>%
    select(Sequence, Leading_razor_protein, Identifier, Gene) %>%
    arrange(Gene, Identifier, Sequence)
} else {
  res_final <- res1 %>%
    select(Sequence, Leading_razor_protein, Identifier, Gene) %>%
    arrange(Gene, Identifier, Sequence)
}

# ===================== 5) Save + show =====================
readr::write_csv(res_final, "gald_unique_peptides_with_protein_identifier_gene.csv")
res_final

```

d

```{r}
# --- CONTINUE FROM YOUR SCRIPT WHERE `res_final` IS PRODUCED ---

# 1) Clean LRP string and keep only peptides that actually have an LRP
lrp_tbl <- res_final %>%
  mutate(lead_key = norm_key(Leading_razor_protein)) %>%
  filter(!is.na(lead_key) & nzchar(lead_key))

# 2) Unique protein list (with optional identifier/gene columns if available)
unique_protein_list <- lrp_tbl %>%
  distinct(lead_key, Leading_razor_protein, Identifier, Gene) %>%
  arrange(Gene, Identifier, Leading_razor_protein)

# 3) Number of unique proteins
n_unique_proteins <- nrow(unique_protein_list)

# 4) (Nice to have) How many unique peptides support each LRP?
peptides_per_protein <- lrp_tbl %>%
  group_by(Leading_razor_protein, Identifier, Gene) %>%
  summarise(n_unique_peptides = n_distinct(Sequence), .groups = "drop") %>%
  arrange(desc(n_unique_peptides), Gene, Identifier)

# 5) (Diagnostics) GALD-unique peptides that did NOT get an LRP
no_lrp <- res_final %>%
  filter(is.na(Leading_razor_protein) | !nzchar(Leading_razor_protein)) %>%
  distinct(Sequence)

# 6) Save results
readr::write_csv(unique_protein_list,     "gald_unique_LRP_list.csv")
readr::write_csv(peptides_per_protein,    "gald_unique_LRP_with_peptide_counts.csv")
readr::write_csv(no_lrp,                  "gald_unique_peptides_no_LRP.csv")

# 7) Print concise outputs
message("Number of unique Leading razor proteins for GALD-unique peptides: ", n_unique_proteins)
unique_protein_list

```

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(pheatmap)
  library(matrixStats)
  library(RColorBrewer)
})

id_col <- "Sequence"
coverage_thresh <- 0.30   # keep peptides present in ≥40% of samples

# 1) wide intensity matrix
wide_int <- df_pep %>%
  select(!!sym(id_col), sample, Intensity) %>%
  pivot_wider(names_from = sample, values_from = Intensity)

X <- wide_int %>% select(-!!sym(id_col)) %>% as.matrix()
rownames(X) <- wide_int[[id_col]]

# 2) filter by coverage
cov_frac <- rowMeans(!is.na(X))
Xf <- X[cov_frac >= coverage_thresh, , drop = FALSE]

# 3) row-median impute for viz only
idx <- which(is.na(Xf), arr.ind = TRUE)
if (length(idx)) {
  rmed <- rowMedians(Xf, na.rm = TRUE)
  Xf[idx] <- rmed[idx[,1]]
}

# 4) row z-score
Xz <- t(scale(t(Xf)))

# 5) sample annotation
ann <- df_pep %>%
  distinct(sample, group) %>%
  filter(sample %in% colnames(Xz)) %>%
  column_to_rownames("sample")

grp_levels <- unique(ann$group)
grp_cols <- setNames(
  RColorBrewer::brewer.pal(max(3, length(grp_levels)), "Set2")[seq_along(grp_levels)],
  grp_levels
)
ann_colors <- list(group = grp_cols)

# 6) heatmap
pheatmap(Xz,
         show_rownames = FALSE,
         annotation_col = ann,
         annotation_colors = ann_colors,
         clustering_distance_rows = "correlation",
         clustering_distance_cols = "correlation",
         main = paste0("Peptide × Sample Heatmap (≥", coverage_thresh*100, "% coverage, z-scored)"),
         color = colorRampPalette(c("navy","white","firebrick3"))(50))

```

#### Looking for unique peptides

```{r}
# make sure dplyr's count is used, and names are normalized
library(tidyverse)

names(ev) <- gsub(" ", "_", names(ev))   # e.g. "Protein IDs" -> "Protein_IDs"
has_pids  <- "Protein_IDs" %in% names(ev)

norm_key <- function(x){
  x <- toupper(coalesce(as.character(x), ""))
  x <- sub(";.*$", "", x)
  x <- sub("-\\d+$", "", x)
  trimws(x)
}

pep_prot_long <- if (has_pids) {
  ev %>%
    transmute(Sequence = as.character(Sequence),
              Protein_IDs = as.character(Protein_IDs)) %>%
    filter(!is.na(Protein_IDs), nzchar(Protein_IDs)) %>%
    distinct() %>%
    tidyr::separate_rows(Protein_IDs, sep = ";") %>%
    transmute(Sequence, protein_key = norm_key(Protein_IDs))
} else {
  ev %>%
    transmute(Sequence = as.character(Sequence),
              Leading_razor_protein = as.character(Leading_razor_protein)) %>%
    filter(!is.na(Leading_razor_protein), nzchar(Leading_razor_protein)) %>%
    distinct() %>%
    transmute(Sequence, protein_key = norm_key(Leading_razor_protein))
}

# ✅ force dplyr::count (avoid plyr::count masking)
pep_map_counts <- dplyr::count(pep_prot_long, Sequence, name = "n_proteins")

# tag GALD-unique peptides as proteotypic (n_proteins==1) vs shared
gald_pep_class <- tibble(Sequence = gald_unique_peptides) %>%
  left_join(pep_map_counts, by = "Sequence") %>%
  mutate(n_proteins = coalesce(n_proteins, 0L),
         class = case_when(n_proteins == 1 ~ "proteotypic",
                           n_proteins >  1 ~ "shared",
                           TRUE            ~ "unmapped"))

table(gald_pep_class$class)
head(gald_pep_class %>% arrange(desc(n_proteins)), 10)

```

```{r}
gald_lab <- "Fetal_liver_lysate_bait"   # adjust if your label differs

# keep only proteotypic sequences
proteotypic_seq <- gald_pep_class %>% filter(class=="proteotypic") %>% pull(Sequence)

# map those sequences to protein_key
pep2prot <- pep_prot_long %>%
  filter(Sequence %in% proteotypic_seq) %>%
  distinct(Sequence, protein_key)

# build protein-level presence per group from proteotypic peptides only
prot_presence <- df_pep %>%
  filter(Sequence %in% proteotypic_seq) %>%
  mutate(present = !is.na(Intensity)) %>%
  inner_join(pep2prot, by = "Sequence") %>%
  group_by(protein_key, sample, group) %>%
  summarise(present = any(present), .groups = "drop") %>%
  group_by(protein_key, group) %>%
  summarise(n_samples_present = sum(present), .groups = "drop")

# convert to fractions for thresholding
totals <- df_pep %>% distinct(sample, group) %>% dplyr::count(group, name="n_samp")
prot_prev <- prot_presence %>% left_join(totals, by="group") %>%
  mutate(frac = n_samples_present / n_samp)

# strict GALD-only (present in GALD, absent in all others)
gald_only_strict <- prot_presence %>%
  mutate(is_gald = group==gald_lab) %>%
  summarise(in_gald = any(is_gald & n_samples_present>0),
            in_others = any(!is_gald & n_samples_present>0),
            .by = protein_key) %>%
  filter(in_gald & !in_others) %>% pull(protein_key)

length(gald_only_strict)
head(gald_only_strict)

```

```{r}
# read original.tsv and normalize names
prot <- readr::read_tsv("original.tsv", show_col_types = FALSE)
names(prot) <- gsub(" ", "_", names(prot))
stopifnot(all(c("identifier","leading_razor_protein","gene_name") %in% names(prot)))

# two mapping routes into original.tsv
prot_map_lr <- prot %>% transmute(protein_key = norm_key(leading_razor_protein),
                                  Identifier = identifier, Gene = gene_name)
prot_map_id <- prot %>% transmute(protein_key = norm_key(identifier),
                                  Identifier = identifier, Gene = gene_name)
prot_map <- bind_rows(prot_map_lr, prot_map_id) %>% distinct(protein_key, .keep_all = TRUE)

# supporting proteotypic peptides per protein
support <- pep2prot %>%
  group_by(protein_key) %>%
  summarise(n_proteotypic_peptides = n_distinct(Sequence),
            peptides = paste(sort(unique(Sequence)), collapse="; "),
            .groups="drop")

# final table for strict GALD-only proteins
gald_only_tbl <- tibble(protein_key = gald_only_strict) %>%
  left_join(prot_map, by="protein_key") %>%
  left_join(support, by="protein_key") %>%
  arrange(Gene, Identifier)

readr::write_csv(gald_only_tbl, "gald_only_proteins_proteotypic_peptides.csv")
gald_only_tbl

```

#### Looking at the missing peptides here

```{r}
# Strict LRP → (identifier, gene) mapping
suppressPackageStartupMessages({
  library(readr)
  library(dplyr)
})

# ==== INPUTS (exact names as provided) ====
path_evidence <- "evidence.txt"   # has: 'Sequence', 'Leading razor protein'
path_original <- "original.tsv"   # has: 'leading razor protein', 'identifier', 'gene name'

# ==== LOAD ====
ev <- read_tsv(path_evidence, guess_max = 2e5, show_col_types = FALSE)
orig <- read_tsv(path_original,  guess_max = 2e5, show_col_types = FALSE)

# ==== HARD CHECKS ====
stopifnot(all(c("Sequence", "Leading razor protein") %in% names(ev)))
stopifnot(all(c("leading razor protein", "identifier", "gene name") %in% names(orig)))

# ==== LRPs present in evidence ====
lrps_ev <- ev %>%
  transmute(LRP = `Leading razor protein`) %>%
  filter(!is.na(LRP), LRP != "") %>%
  distinct()

# ==== Map LRPs to identifier and gene in original.tsv ====
mapping <- orig %>%
  filter(`leading razor protein` %in% lrps_ev$LRP) %>%
  transmute(
    LRP       = `leading razor protein`,
    identifier = identifier,
    gene       = `gene name`
  ) %>%
  distinct() %>%
  arrange(LRP, identifier, gene)

# ==== WRITE ====
out_csv <- "lrp_to_identifier_gene_from_evidence.csv"
write_csv(mapping, out_csv)

# ==== QUICK SUMMARY ====
n_lrps_ev   <- nrow(lrps_ev)
n_mapped    <- n_distinct(mapping$LRP)
n_unmapped  <- n_lrps_ev - n_mapped

cat("LRPs in evidence:  ", n_lrps_ev, "\n",
    "LRPs mapped:       ", n_mapped, "\n",
    "LRPs unmapped:     ", n_unmapped, "\n",
    "Output file:       ", out_csv, "\n", sep = "")


```

```{r}
# attach groups via your sample map
smap <- readr::read_tsv("sample_map.tsv", show_col_types = FALSE)
names(smap) <- gsub(" ", "_", names(smap))
stopifnot(all(c("Raw_file","group") %in% names(smap)))

# counts of UNIQUE peptide sequences per group (not double-counted across runs)
per_group <- ev_missing %>%
  distinct(Sequence, Raw_file) %>%
  left_join(smap %>% select(Raw_file, group) %>% distinct(), by = "Raw_file") %>%
  group_by(group) %>%
  summarise(n_unlinked_unique_peptides = n_distinct(Sequence), .groups = "drop") %>%
  arrange(desc(n_unlinked_unique_peptides))

# overall count
overall <- tibble(
  total_rows_in_evidence = nrow(ev),
  rows_with_both_fields_missing = nrow(ev_missing),
  unique_sequences_missing = nrow(unlinked_peptides)
)

per_group
overall

```

```{r}
# ============================================================
# GALD peptide ↔ protein/gene mapping and overlap check
# Compatible with the given proteinGroups.txt column names
# ============================================================

suppressPackageStartupMessages({
  library(tidyverse)
  library(readr)
  library(stringr)
})

# ---------------- USER INPUTS (EDIT) ------------------------
# MaxQuant outputs
evidence_fp       <- "evidence.txt"          # must have: Sequence, Proteins, Raw file (or Raw.file), Intensity
proteinGroups_fp  <- "proteinGroups.txt"     # must have: Majority protein IDs, Gene names

# Your tidy long table (optional, used to derive GALD-specific IDs if you don't provide a list)
# must have: identifier, sample, Intensity, group
original_fp       <- "original.tsv"

# Map Raw file -> sample + group
# must have columns that can be normalized to: Raw.file, sample, group
sample_map_fp     <- "sample_map.tsv"

# If you already have GALD-specific IDs (one column named 'identifier' with either gene symbols OR UniProt),
# point to it; otherwise set to NULL to derive from original.tsv
gald_id_list_fp   <- NULL   # e.g. "gald_specific_identifiers.tsv"

# Group labels
g_gald            <- "Fetal_liver_lysate_bait"   # the GALD case group label used in your data
control_groups    <- NULL  # if NULL, all groups != g_gald are treated as controls

# Presence rules (when deriving GALD-specific identifiers from original.tsv)
thr_prop_gald     <- 0.0   # ≥60% of GALD samples present
thr_prop_ctrl     <- 0.0   # ≤10% of pooled-control samples present

# Peptide "present" definition from evidence.txt
present_if <- function(x) is.finite(x) && x > 0

# Output folder
out_dir <- "gald_mapping_check"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

# Output files
out_pep2map              <- file.path(out_dir, "pep2_uniprot_gene.tsv.gz")
out_pep_presence         <- file.path(out_dir, "peptide_presence_by_group.tsv.gz")
out_gald_only_peptides   <- file.path(out_dir, "gald_only_peptides.tsv")
out_gald_id_set          <- file.path(out_dir, "gald_specific_identifiers_used.tsv")
out_overlap              <- file.path(out_dir, "overlap_galdonly_peptides_to_galdIDs.tsv")
out_summary              <- file.path(out_dir, "summary.txt")

# ---------------- HELPERS -----------------------------------
to_uniprot <- function(x){
  # "sp|Q9BQ39|DDX50_HUMAN" -> "Q9BQ39"; if already plain, keep as-is
  acc <- sub("^.*\\|([A-Z0-9]+)\\|.*$", "\\1", x)
  ifelse(nchar(acc) > 0 & acc != x, acc, x)
}
as_char <- function(x) as.character(replace(x, is.na(x), ""))

# ---------------- LOAD DATA ---------------------------------
message("Reading evidence.txt …")
evidence <- read_tsv(evidence_fp, guess_max = 1e6, show_col_types = FALSE)

stopifnot(all(c("Sequence","Proteins") %in% names(evidence)))
raw_file_col <- if ("Raw file" %in% names(evidence)) "Raw file" else if ("Raw.file" %in% names(evidence)) "Raw.file" else NA_character_
stopifnot(!is.na(raw_file_col))

intensity_col <- if ("Intensity" %in% names(evidence)) "Intensity" else if ("Intensity.Value" %in% names(evidence)) "Intensity.Value" else NA_character_
stopifnot(!is.na(intensity_col))

message("Reading proteinGroups.txt …")
proteinGroups <- read_tsv(proteinGroups_fp, guess_max = 5e5, show_col_types = FALSE)
stopifnot(all(c("Majority protein IDs","Gene names") %in% names(proteinGroups)))

message("Reading sample_map.tsv …")
samp_map <- read_tsv(sample_map_fp, show_col_types = FALSE)
# normalize names & select needed columns
names(samp_map) <- str_replace_all(names(samp_map), "\\s+", ".")
raw_candidates <- c("raw_file","Raw.file","Raw.file.name","raw","RawFile")
raw_col <- raw_candidates[raw_candidates %in% names(samp_map)][1]
stopifnot(!is.na(raw_col))
stopifnot(all(c("sample","group") %in% names(samp_map)))
samp_map <- samp_map %>%
  transmute(Raw.file = as_char(!!sym(raw_col)),
            sample   = as_char(sample),
            group    = as_char(group))

# ---------------- UniProt → gene map ------------------------
message("Building UniProt→gene mapping from proteinGroups.txt …")
u2g <- proteinGroups %>%
  select(`Majority protein IDs`, `Gene names`) %>%
  tidyr::separate_rows(`Majority protein IDs`, sep = ";") %>%
  mutate(uniprot = to_uniprot(`Majority protein IDs`)) %>%
  tidyr::separate_rows(`Gene names`, sep = ";") %>%
  transmute(uniprot = as_char(uniprot),
            gene    = as_char(`Gene names`)) %>%
  filter(uniprot != "", gene != "") %>%
  distinct()

# ---------------- peptide → UniProt (+gene) -----------------
message("Building peptide→protein mapping from evidence.txt …")
pep2all <- evidence %>%
  select(Sequence, Proteins) %>%
  mutate(Sequence = as_char(Sequence), Proteins = as_char(Proteins)) %>%
  filter(Sequence != "", Proteins != "") %>%
  tidyr::separate_rows(Proteins, sep = ";") %>%
  transmute(Sequence, uniprot = to_uniprot(Proteins)) %>%
  distinct()

pep2gene <- pep2all %>% left_join(u2g, by = "uniprot")

write_tsv(pep2gene, out_pep2map)

# ---------------- peptide presence by group -----------------
message("Computing peptide presence by group …")
pep_presence <- evidence %>%
  transmute(Sequence = as_char(!!sym("Sequence")),
            Raw.file = as_char(!!sym(raw_file_col)),
            Intensity = !!sym(intensity_col)) %>%
  filter(Sequence != "", Raw.file != "") %>%
  group_by(Sequence, Raw.file) %>%
  summarize(present = any(present_if(Intensity), na.rm = TRUE), .groups = "drop") %>%
  left_join(samp_map, by = "Raw.file") %>%
  filter(!is.na(group) & group != "")

pep_by_group <- pep_presence %>%
  group_by(Sequence, group) %>%
  summarize(n_present = sum(present),
            n_total   = n(),
            frac      = n_present / n_total,
            .groups   = "drop")

write_tsv(pep_by_group, out_pep_presence)

# ---------------- define GALD-only peptides -----------------
all_groups <- sort(unique(pep_by_group$group))
stopifnot(g_gald %in% all_groups)
if (is.null(control_groups)) control_groups <- setdiff(all_groups, g_gald)

pep_gc <- pep_by_group %>%
  mutate(is_gald = group == g_gald,
         is_ctrl = group %in% control_groups) %>%
  group_by(Sequence) %>%
  summarize(frac_gald = max(frac[is_gald],    na.rm = TRUE) %>% replace_na(0),
            frac_ctrl = max(frac[is_ctrl],    na.rm = TRUE) %>% replace_na(0),
            .groups   = "drop")

gald_only_peptides <- pep_gc %>%
  filter(frac_gald > 0, frac_ctrl == 0) %>%
  arrange(desc(frac_gald)) %>%
  pull(Sequence)

write_tsv(tibble(Sequence = gald_only_peptides), out_gald_only_peptides)

# --------- define GALD-specific ID set (gene or UniProt) ----
gald_ids <- NULL
gald_id_namespace <- NULL

if (!is.null(gald_id_list_fp) && file.exists(gald_id_list_fp)) {
  message("Using user-provided GALD-specific identifier list …")
  gald_ids <- read_tsv(gald_id_list_fp, show_col_types = FALSE) %>%
    rename(identifier = 1) %>%
    transmute(identifier = as_char(identifier)) %>%
    filter(identifier != "") %>%
    distinct()
  # heuristic: if all look like UniProt (letters+digits, optional -isoform), call it UniProt
  is_unip <- all(str_detect(gald_ids$identifier, "^[A-Z0-9]+(-\\d+)?$"))
  gald_id_namespace <- if (is_unip) "uniprot" else "gene"
} else if (file.exists(original_fp)) {
  message("Deriving GALD-specific identifiers from original.tsv …")
  original <- read_tsv(original_fp, guess_max = 5e5, show_col_types = FALSE)
  stopifnot(all(c("identifier","sample","Intensity","group") %in% names(original)))

  oid <- original %>%
    mutate(present = present_if(Intensity)) %>%
    group_by(identifier, group) %>%
    summarize(n_present = sum(present),
              n_total   = n(),
              frac      = n_present / n_total,
              .groups   = "drop") %>%
    mutate(is_gald = group == g_gald,
           is_ctrl = group %in% control_groups) %>%
    group_by(identifier) %>%
    summarize(frac_gald = max(frac[is_gald], na.rm = TRUE) %>% replace_na(0),
              frac_ctrl = max(frac[is_ctrl], na.rm = TRUE) %>% replace_na(0),
              .groups   = "drop") %>%
    filter(frac_gald >= thr_prop_gald, frac_ctrl <= thr_prop_ctrl) %>%
    transmute(identifier) %>% distinct()

  gald_ids <- oid

  # namespace guess for original$identifier
  is_unip <- all(str_detect(gald_ids$identifier, "^[A-Z0-9]+(-\\d+)?$"))
  gald_id_namespace <- if (is_unip) "uniprot" else "gene"
} else {
  message("No GALD ID list and no original.tsv found — falling back to genes mapped from GALD-only peptides.")
  gald_ids <- pep2gene %>%
    filter(Sequence %in% gald_only_peptides, !is.na(gene), gene != "") %>%
    transmute(identifier = gene) %>% distinct()
  gald_id_namespace <- "gene"
}

write_tsv(gald_ids, out_gald_id_set)

# --------------------- overlap check ------------------------
# Map peptides into the SAME namespace as gald_ids
if (gald_id_namespace == "gene") {
  pep_ids <- pep2gene %>%
    filter(!is.na(gene) & gene != "") %>%
    transmute(Sequence, identifier = gene) %>%
    distinct()
} else {
  # UniProt namespace
  pep_ids <- pep2all %>%
    transmute(Sequence, identifier = uniprot) %>%
    distinct()
}

overlap_tbl <- pep_ids %>%
  mutate(is_gald_only_pep = Sequence %in% gald_only_peptides,
         is_in_gald_id    = identifier %in% gald_ids$identifier)

support_tbl <- overlap_tbl %>%
  filter(is_gald_only_pep & is_in_gald_id) %>%
  left_join(pep2all, by = c("Sequence", "identifier" = "uniprot")) %>%
  # identifier is UniProt if namespace==UniProt; for genes this join may be sparse; keep distinct rows
  distinct(Sequence, identifier)

write_tsv(support_tbl, out_overlap)

# ---------------------- SUMMARY -----------------------------
n_peps_total       <- n_distinct(evidence$Sequence)
n_peps_to_uniprot  <- nrow(pep2all %>% distinct(Sequence))
n_peps_to_gene     <- nrow(pep2gene %>% filter(!is.na(gene) & gene != "") %>% distinct(Sequence))
n_gald_only        <- length(gald_only_peptides)
n_gald_ids         <- nrow(gald_ids)
n_support          <- nrow(support_tbl %>% distinct(Sequence))

summary_lines <- c(
  "===== GALD peptide ↔ protein/gene mapping summary =====",
  sprintf("Total unique peptides in evidence.txt:              %d", n_peps_total),
  sprintf("Peptides mapped to ANY UniProt ID:                  %d", n_peps_to_uniprot),
  sprintf("Peptides mapped to a gene symbol:                   %d", n_peps_to_gene),
  sprintf("GALD-only peptides (present in GALD, absent ctrl):  %d", n_gald_only),
  sprintf("GALD-specific identifiers in set (%s):              %d", gald_id_namespace, n_gald_ids),
  sprintf("GALD-only peptides mapping into GALD IDs:           %d", n_support),
  "",
  "Outputs:",
  paste0(" - ", out_pep2map),
  paste0(" - ", out_pep_presence),
  paste0(" - ", out_gald_only_peptides),
  paste0(" - ", out_gald_id_set),
  paste0(" - ", out_overlap)
)

writeLines(summary_lines)
writeLines(summary_lines, out_summary)

# quick cross-tab for sanity
message("\nCross-tab (GALD-only peptide vs in GALD-ID set):")
print(overlap_tbl %>% count(is_gald_only_pep, is_in_gald_id))

if (n_support > 0) {
  message("\nExample supporting peptides:")
  print(support_tbl %>% head(20))
} else {
  message("\nNo overlaps under current rules.")
  message("Common causes: namespace mismatch (UniProt vs gene), isoform suffixes,")
  message("or GALD-ID set defined in a different space than the peptide mapping.")
}


```
